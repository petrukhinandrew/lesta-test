# Вопрос 1

Реализация в `isEven.py`

Хотя привычнее видеть `%2`, у такой операции нет битовой реализации в общем случае (`%n`) и она потенциально медленнее `&1` (хотя не исключено, что компилятор\интерпретатор умеют оптимизировать специальные случаи вроде `%2` и сводить их к `&1`).

# Вопрос 2

Решение в `circular_buf.py`, версия python >= 3.8 (оператор `:=` используется в тестировании) 

Первая реализация использует список и два указателя - добавление и удаление элементов будет происходить за $O(1)$. Предложенная реализация не поддерживает запись новых элементов "поверх" непрочитанных. Проблема такого решения - может понадобиться хранить большой список в памяти.

Втора реализиация использует `deque` (в смысле реализации, это двусвязный список массивов относительно небольшого размера) - это выгоднее в случаях с большим буфером, однако добавление и удаление будет работать за амортизированное $O(1)$ - это почти наверное $O(1)$, но иногда могут происходить аллокации для блоков (массивов небольшого размера)

# Вопрос 3

Кажется, решение зависит от процессора (речь про поддержку AVX) и приведенное не будет абсолютно оптимизированным. Так же, компилятор может делать не самые явные оптимизации в случае C++ (про оптимизации python не знаю). 

Сначала поймем, что любая сортировка потребует хотя бы $\Omega(n \cdot \log(n))$ сравнений. Сравнение двух чисел мы умеем делать за $O(1)$ процессорных тиков. Хотим минимизировать число аллокаций в куче (поэтому не подходит MergeSort - стэка может просто не хватить) и число "обменов" элементов (не подойдет HeapSort - там нам нужно "свапать" почти все элементы). Можем использовать QuickSort - in-place алгоритм, который не будет "обменивать" элементы массива, которые не нужно обменивать.

Решение в `quicksort.cpp`